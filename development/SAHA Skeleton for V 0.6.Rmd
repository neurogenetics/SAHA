---
title: "SAHA Skeleton for V 0.6"
author: "Acri, Dominic"
date: "2024-07-29"
output:
  pdf_document: default
  html_document: default
---
#Prior to this document
Location:
* All functions were moved into ./dev_package/SAHA/R/*.R
  * Create_SAHA_object
  * Initialize_Markers
  * Tune_Markers
  * Marker_Diversity
  * Marker_Richness
  * SAHA_lookup_cluster
  * Run_Marker_Based
  * Create_MarkerBased_Viz
  * Investigate_Marker_Based
  * Initialize_MarkerFree
  * Downsample
  * NormalizeDS
  * CorrelateDS
  * Create_MarkerFree_Viz
  * Investigate_MarkerFree
  
To do:

To create:
* Plot feature that calls each from ann@results
* Figure out how to call ABC from package data
* Plot feature that wraps into a summary figure
* Promptable automated function
* Demo to write to new_cluster_ids for Seurat


## Setting Variables

```{r Load Libraries, echo=FALSE}
library(tidyverse)
library(ComplexHeatmap)
library(circlize)
library(methods)
library(vegan)
library(ggrepel)
library(eulerr)
library(reshape2)
library(corrplot)
library(ggpubr)

```

```{r Path Loadings}
wrk_dir="/data/acridj/project/SAHA/"
skl_file=paste0(wrk_dir,"skeleton_files/")
ABC_meta=paste0(wrk_dir,"ABC_meta_input.csv")
demo_dir=paste0(wrk_dir,"demo/")

```

```{r Variable Loadings}
#demo = readRDS("/data/ADRD/SAHA/PWKvB6_B6coarse_downsamp.rds")
meta = read.csv(ABC_meta)
demo_AE=read.csv(paste0(demo_dir,"demo_AE.csv"))
demo_marker=read.csv(paste0(demo_dir,"20230821_PWKvB6_B6coarse_res0.4_cluster_markers.csv"))
ABC_CB_AE=read.csv(paste0(skl_file,"CB_AvExp.csv"))
ABC_CB_Markers=read.csv(paste0(skl_file,"CB_markers.csv"))
```
##Create SAHA object!!!

```{r Create SAHA object}

#It was working... then I broke it by trying to let it merge together
Create_SAHA_object <- function(query, db,data_type,existing=NULL){
  #SAHA Object will be a class made up of 6 components
  # 1. query = a list of df's containing either Markers or AvgExp
  # 2. db = a list of df's containing either Markers or AvgExp
  # 3. ann1 = a list of df's containing matched query and db markers for self-similarity analyses
  # 4. ann2 = a list of df's containing matched query and db markers for marker-based analyses
  # 5. ann3 = a list of df's containing matched query and db markers for marker-free analyses
  # 6. results = a list of objects containing final analyses  required to make plots
  if (is.null(existing)){
  setClass("SAHA", 
         slots = c(
           data_type = "character",
           query = "list",
           db = "list",
           ann1 = "list", 
           ann2 = "list",
           ann3 = "list",
           results = "list"
         )
)
    setMethod("show", "SAHA", function(object) {
  cat(is(object)[[1]], "\n",
      "  data_type: ", object@data_type, "\n",
      "  Your query contains:  ", length(unique(object@query$Markers$cluster))," clusters.", "\n",
       "  Your database contains:  ", length(unique(object@db$Markers$cluster))," possible annotations.", "\n",
      sep = ""
  )
})  
  }else{print("Merging new markers into existing SAHA object.")}
  

################# 
# Code written in Gemini for printing different slot types w/ lapply. I feel okay about it so work with it to adapt to printign diferent slot types.....
#################  
#setMethod("set", "yourClassName", function(object, ..., verbose = TRUE) {
  # ... standard set method logic ...

#  if (verbose) {
#    slots <- slotNames(object)
#    lapply(slots, function(slot) {
#      value <- slot(object, slot)
#      if (!is.null(value) && length(value) > 0) {
#        cat(paste0("Slot ", slot, ":\n"))
#        
#        # Determine slot type and apply appropriate summary function
#        if (is.data.frame(value)) {
#          print(head(value))  # Example: print first few rows
 #       } else if (is.list(value) && all(sapply(value, is.data.frame))) {
          # Handle list of data frames
#          lapply(value, function(df) print(head(df)))
#        } else if (is.character(value)) {
#          cat(paste0("Value: ", value))
#        } else {
#          print(summary(value))  # Default summary for other types
#        }
#      }
#    })
#  }

#  object
#})
  
 #### IF statement that allows users to either load Marker or AvgExp data
  if (data_type == "Markers") {
  #loading query data
  print("You have selected to load Query and DB marker data.")
     #1. Read in your queried data as a df or csv
   if (inherits(query, "data.frame")) {
      # If query is already a data frame, use it directly
      query_marker_data <- query
   } else {
      # If query is a path to a CSV file, read it into a data frame
      query_marker_data <- read.csv(query)
   }
  
 #loading db data ########### THIS NEEDS TO BE A CHOICE TO ALLOW USERS TO LOAD PRE-LOADED PACKAGE DATA!!!!
  #2. Read in your db data as a df or csv
   if (inherits(db, "data.frame")) {
      # If query is already a data frame, use it directly
      db_marker_data <- db
   } else {
      # If query is a path to a CSV file, read it into a data frame
      db_marker_data <- read.csv(db)
   } 
  }else{
  print("You have selected to load Query and DB AvgExp data.")   
    #1. Read in your queried data as a df or csv
   if (inherits(query, "data.frame")) {
      # If query is already a data frame, use it directly
      query_AvgExp_data <- query
   } else {
      # If query is a path to a CSV file, read it into a data frame
      query_AvgExp_data <- read.csv(query)
   }
  
 #loading db data ########### THIS NEEDS TO BE A CHOICE TO ALLOW USERS TO LOAD PRE-LOADED PACKAGE DATA!!!!
  #2. Read in your db data as a df or csv
   if (inherits(db, "data.frame")) {
      # If query is already a data frame, use it directly
      db_AvgExp_data <- db
   } else {
      # If query is a path to a CSV file, read it into a data frame
      db_AvgExp_data <- read.csv(db)
   }
}
  if (data_type == "Markers") {
    temp_ann <- new("SAHA", data_type=data_type, query = list(Markers=data.frame(query_marker_data), AvgExp=data.frame(NULL)),db = list(Markers=data.frame(db_marker_data), AvgExp=data.frame(NULL)))
  }else if (data_type =="AvgExp"){
    temp_ann <- new("SAHA", data_type=data_type, query = list(Markers=data.frame(NULL), AvgExp=data.frame(query_AvgExp_data)),db = list(Markers=data.frame(NULL), AvgExp=data.frame(db_AvgExp_data)))
  }
  
  if (data_type == "Markers") {
    #3A. Check to see that all rownames of query are in rownames of db
    print(paste("Loaded database contains", length(unique(temp_ann@db$Markers$cluster)),"unique cell types."))
  #print the name of the loaded dataset
  print(paste("Loaded query dataset contains", length(unique(temp_ann@query$Markers$cluster)),"unique clusters."))
  }else if (data_type =="AvgExp"){
    #3B. Check to see that all rownames of query are in rownames of db
    print(paste("Loaded database contains", length(colnames(temp_ann@db$AvgExp)),"unique cell types."))
  #print the name of the loaded dataset
  print(paste("Loaded query dataset contains", length(colnames(temp_ann@query$AvgExp)),"unique clusters."))
  }

#the else could use an inherit that confirms that existing is a SAHA object....
  if (is.null(existing)) {
  ann=temp_ann
  return(ann)
  }else{
    if (data_type=="Markers") {
      existing@query$Markers = data.frame(temp_ann@query$Markers)
      existing@db$Markers = data.frame(temp_ann@db$Markers)
      existing@data_type = "AvgExp & Markers"
    }else if(data_type=="AvgExp"){
      existing@query$AvgExp = data.frame(temp_ann@query$AvgExp)
      existing@db$AvgExp = data.frame(temp_ann@db$AvgExp)
      existing@data_type = "Markers & AvgExp"
    }
  return(existing)
  }
  
  
}



```

```{r}
ann=Create_SAHA_object(query = demo_marker,db = ABC_CB_Markers,data_type = "Markers")
ann
```



## Flavor 1: Self-identity

```{r Functions F1}
#

Initialize_Self_Similiarity <- function(ann,slot){
    if (slot=="AvgExp") {
    temp=ann@query$AvgExp
    temp <- temp %>%
      column_to_rownames("X")
    cor_mat <- cor(temp)
    # Print the resulting dataframe
    ann@ann1$AvgExp_selfsim_matrix=cor_mat
    
      return(ann)
    }else if(slot=="Markers"){
    temp=ann@query$Markers
    df = data.frame(temp[,c("gene","cluster")])
    df$incidence = 1
  
    # Reshape using spread (assuming values for each id and time combination)
    wide_data <- df %>%
      spread(gene, incidence)  # Spreads "value" based on "time" for each "id"
  
    # Print the resulting wide dataframe
    wide_data <- wide_data %>%
      column_to_rownames("cluster") 
  
    # Print the resulting dataframe
    ann@ann1$Marker_selfsim_matrix=wide_data
    return(ann)
    }

}

Create_SelfSimilarity_Viz <- function(ann, slot,assay_db="RNA") {
  # Ensure data is numeric
  if(slot=="Markers"){
  df <- as.matrix(ann@ann1$Marker_selfsim_matrix)
  df[is.na(df)] <- 0  # Replace NA with 0

  # Calculate shared features
  overlap_matrix <- df %*% t(df)  

 # Convert to matrix
  mat <- as.matrix(overlap_matrix)
  
  # Create row and column annotations (optional)
  row_ann <- rowAnnotation(cluster = factor(rownames(mat)))
  col_ann <- columnAnnotation(cluster = factor(colnames(mat)))
  
  mat2 <- log10(mat+1)
  
  # Create the heatmap
  p1 <- Heatmap(mat2,
          name = paste0("Shared Markers \n Log10(Overlap + 1)"),
          column_title = "Cluster",
          row_title = "Cluster",
          top_annotation = NULL,
          left_annotation = NULL,
          cluster_rows = TRUE,
          cluster_columns = TRUE)
  ann@results$self_similarity$similiarity_heatmap_markers = p1
  return(ann)
  }else if(slot == "AvgExp"){
    cor_mat=ann@ann1$AvgExp_selfsim_matrix
    cor_mat[is.na(cor_mat)]<-0
    rownames(cor_mat) <- gsub(paste0("^",assay_db,"\\.g"), "", rownames(cor_mat))
    colnames(cor_mat) <- gsub(paste0("^",assay_db,"\\.g"), "", colnames(cor_mat))
    col <- colorRampPalette(c("white", "red"))(200)
   # p2 <- corrplot(cor_mat, method = "color", type = "upper", order = "hclust", tl.col = "black",col=col, tl.srt = 45)
    p2 <- Heatmap(cor_mat, 
        name = "Self Similarity Matrix",  # Optional: Set a name for the heatmap
        col = col,  # Color palette
        cluster_rows = TRUE,  # Hierarchical clustering for rows
        cluster_columns = TRUE  # Hierarchical clustering for columns
        #show_colorbar = TRUE
        )  # Display the colorbar
    
  ann@results$self_similarity$similiarity_heatmap_avgexp = p2 
  return(ann)
  }
  
  
}


Initialize_Markers <- function(ann, p_thresh = 0.05, FC_thresh = 1.5, sens_thresh = 0.25, spec_thresh = 0.75){
  # Assuming your dataframe is named 'df' and has columns 'cluster' and 'log2FC'
  # QC reports
  if (all(ann@query$Markers$avg_log2FC >=0)) {
    ann_subset=subset(ann@query$Markers,(p_val_adj < p_thresh & 
                                                  avg_log2FC > log(FC_thresh,base = 2) & 
                                                  pct.1 > sens_thresh & 
                                                  pct.2 < spec_thresh))
  }else{
    
    print("WARNING: Loaded query dataset contains markers with either negative or NA log2FC values. We gently discourage the use of negative or absent markers in cluster identification, however the pipeline will proceed regardless.")
    ann_subset=subset(ann@query$Markers,(p_val_adj < p_thresh & 
                                                  avg_log2FC > log(FC_thresh,base = 2) & 
                                                  pct.1 > sens_thresh & 
                                                  pct.2 < spec_thresh))
  }
  
  marker_summary <- ann_subset%>%
    group_by(cluster) %>%
    summarise(n_markers =n())
  
  print(paste("Loaded query dataset contains", length(unique(ann_subset$cluster)),"unique clusters with a median of", summary(marker_summary$n_markers)[3], "markers per cluster and a range from",summary(marker_summary$n_markers)[1],"to",summary(marker_summary$n_markers)[6],"markers per cluster."))
  
  
  #ann1$db #need to filter these!!!!!!!!!!!!!!!
  # function to filter by either number or percentile
  db_subset = subset(ann@db$Markers,(p_val_adj < p_thresh & 
                                                  avg_log2FC > log(FC_thresh,base = 2) & 
                                                  pct.1 > sens_thresh & 
                                                  pct.2 < spec_thresh))

  
    db_marker_summary <- db_subset%>%
    group_by(cluster) %>%
    summarise(n_markers =n())
  
  print(paste("Loaded db dataset contains", length(unique(db_subset$cluster)),"unique clusters with a median of", summary(db_marker_summary$n_markers)[3], "markers per cluster and a range from",summary(db_marker_summary$n_markers)[1],"to",summary(db_marker_summary$n_markers)[6],"markers per cluster."))
  print("If these summaries match your expetaction for running the SAHA pipeline, no further action is needed. If you would like to re-define markers based on unique p_value or log2FC cutoffs, please re-run Initialize_SAHA() with arguments for thresholds. Otherwise, db markers can be specified using Tune_Markers()")
    print(marker_summary)
    print(db_marker_summary)
  
  ##check how 
  if (length(unique(ann@query$Markers$cluster))!=length(unique(ann_subset$cluster))) {
    print("WARNING: by subsetting your original Markers dataframe with this function, some clusters have dropped out from analysis.")
  }
  #overwrite ann
  ann@ann1$query=ann_subset
  db_subset$cluster <- gsub("-", " ", db_subset$cluster)
  ann@ann1$db=db_subset
  return(ann)
 }

Tune_Markers = function(ann, method, method_value, method_var,set){
  if (is.null(ann@ann1[[set]])) {
    print("WARNING: Markers for the given set have not been initialized. Please run Initialize_Markers() prior to tuning with this funciton.")
  }else{
    if (method == "absolute") {
      tune_subset <- ann@ann1[[set]] %>%
        group_by(cluster)%>%
        top_n(method_value, wt = !!sym(method_var))%>%
        ungroup()
      
    }else if (method == "relative") {
      tune_subset <- ann@ann1[[set]] %>%
        group_by(cluster) %>%
        filter(!!sym(method_var) >= quantile(!!sym(method_var), probs = method_value)) %>%
        ungroup()
    }else{
      print("Method not supported. Please check documentation ?Tune_Markers().")
    }
  }
  input_summary <- ann@ann1[[set]]%>%
    group_by(cluster) %>%
    summarise(n_markers =n())
  
  output_summary <- data.frame(tune_subset)%>%
    group_by(cluster) %>%
    summarise(n_markers =n())  
  print(paste0("By running Tune_Markers() you have lowered the median markers per cluster from ", summary(input_summary$n_markers)[3], " to ",summary(output_summary$n_markers)[3],"."))
  ann@ann1[[set]]=data.frame(tune_subset)
  return(ann)
  
 
}

Marker_Diversity = function(ann){
  ann1=ann@ann1

  df = data.frame(ann1$query[,c("gene","cluster")])

  df$incidence = 1

  # Reshape using spread (assuming values for each id and time combination)
  wide_data <- df %>%
    spread(gene, incidence)  # Spreads "value" based on "time" for each "id"

  # Print the resulting wide dataframe
  wide_data <- wide_data %>%
    column_to_rownames("cluster") 

  # Print the resulting dataframe
  print(wide_data)



  # Calculate Shannon diversity for each cluster
  wide_data <- replace(wide_data, is.na(wide_data), 0)
  shannon_diversity <- diversity(wide_data, index = "shannon")

  shannon_diversity=data.frame(shannon_diversity)
  shannon_diversity$cluster=rownames(shannon_diversity)

  shannon_diversity$cluster=as.numeric(shannon_diversity$cluster)

  model = lm(shannon_diversity ~ 1, data = shannon_diversity)
  CI=confint(model, level = 0.95)

  shannon_diversity$category = factor(
    case_when(
      shannon_diversity$shannon_diversity > CI[2] ~ "High Marker Diversity",
      shannon_diversity$shannon_diversity > CI[1] ~ "Within 95% CI",
      TRUE ~ "Low Marker Diversity"
    ))

# Print or further analyze the shannon_diversity object (numeric vector)
  return(ggplot(shannon_diversity,aes(x=cluster,y=shannon_diversity))+
    geom_point(aes(color = category))+ 
    scale_color_manual(values = c("firebrick4","dodgerblue4","gray75"))+
    geom_hline(yintercept = mean(shannon_diversity$shannon_diversity))+
    geom_hline(yintercept = CI[1],linetype = 2)+
    geom_hline(yintercept = CI[2],linetype = 2)+
    theme_bw()+  # Threshold line 2
    labs(title = "Marker Diversity by Cluster", y = "Shannon Diveristy", x = "Cluster ID", 
         color = "Marker Diversity"))  # Rename legend title

}

MarkerRichness = function(ann, varfeat = NULL){
  if (is.null(varfeat)) {
  ann1=ann@ann1
  df = data.frame(ann1$query[,c("gene","cluster")])
  
  gene_count_by_cluster <- df %>%
  group_by(cluster) %>%  # Filter for rows where gene and cluster values match
  count()  # Count the number of rows after filtering

  print(gene_count_by_cluster) 
  }else{
  ann1=ann@ann1
  df = data.frame(ann1$query[,c("gene","cluster")])
  
  # Count genes present in varfeat
  gene_counts <- df %>%
  mutate(in_varfeat = gene %in% varfeat) %>%  # Create a new column indicating presence
  group_by(cluster)%>%
  summarize(
    all_genes = n(),
    genes_in_varfeat=sum(in_varfeat)  # Count occurrences of each gene and presence flag
  )
# Print the results
print(gene_counts)
  }
}

Investigate_Self_Similarity <- function(ann, cluster1, cluster2,shared_df=NULL) {
  # Ensure data is numeric
  df <- as.matrix(ann@ann1$Marker_selfsim_matrix)
  df[is.na(df)] <- 0

  # Extract rows for the specified clusters
  cluster1_data <- df[paste(cluster1), ]
  cluster2_data <- df[paste(cluster2), ]

  # Find shared features (where both rows have 1)
  bound=cbind(cluster1_data,cluster2_data)
  bound=data.frame(bound)
  venn_input_1=rownames(bound[bound$cluster1_data==1,])
  venn_input_2=rownames(bound[bound$cluster2_data==1,])
  
  # Create a list of sets
  sets <- list(`Cluster_1` = venn_input_1, `Cluster_2` = venn_input_2)

      # Generate the Euler diagram
  euler_venn <- euler(sets)

      # Open a new plotting window
  plot.new()

      # Adjust plot aesthetics
  print(plot(euler_venn,
                 labels = c(paste(cluster1), cluster2),
                 quantities = TRUE,
                 font.main = 14,
                 font.sub = 12,
                 shape = "circle",
                 fill = list(fill = c("pink", "gray"))))
  if (!is.null(shared_df)) {
    return(bound)
  }
  
   }


```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

You can also embed plots, for example:
### Perform F1
```{r Run F1}
##After creating a SAHA object, the query and database will remain UNFILTERED in their respective slots 'ann@query' or 'ann@db'
print(ann@query)
print(ann@db)
#Initiatilizing the first flavor of SAHA prepares a dataset for self-similarity. It is this function that will allow the user to filter based on p_val_adj, avg_log2FC, pct.1, pct.2
ann=Initialize_Markers(ann)

##THIS ONE IF FINE TO PRINT WHEN LOOKING
Marker_Diversity(ann)

ann=Tune_Markers(ann = ann,method = "absolute",method_value = 100,method_var = "avg_log2FC",set = "query")##### use this same one to Tune db!!!!!!!!!!!

#This one is also fine to write like this
Marker_Richness(ann)

varfeat=ann@ann1$query[1:10,"gene"]
Marker_Richness(ann,varfeat = varfeat)
##optional plotting of varfeat
t1=Marker_Richness(ann,varfeat = varfeat)
#This is also fine like this....
ggplot(t1,aes(x=cluster, y = genes_in_varfeat))+
  geom_bar(stat="identity")+
  geom_hline(yintercept = length(varfeat),linetype = 3)+
  theme_bw()



###self sim
ann=Create_SelfSimilarity_Viz(ann,slot = "Markers")
ann=Create_SelfSimilarity_Viz(ann,slot = "AvgExp")

#Investigate Self Sim -- only works for Markers right now....
Investigate_Self_Similarity(wide_data,cluster1 = 14, cluster2 = 20)
shared_marker_df=Investigate_Self_Similarity(wide_data,cluster1 = 14, cluster2 = 20,shared_df = TRUE)



```

## Flavor 2: Marker-based

You can also embed plots, for example:

```{r Functions F2}

SAHA_lookup_cluster <- function(cluster,ann) {
  k=ann@ann1$query[ann@ann1$query$cluster==cluster,"gene"]
  return(summary(factor(ann@ann1$db[ann@ann1$db$SYMBOL %in% k, "cluster"], levels(factor(ann@ann1$db$cluster)))))
      }

Run_Marker_Based <- function(ann){ 
  #5. Making our Master Data Frame
      master_df <- data.frame(summary(factor(ann@ann1$db$cluster)))
      master_df$cluster="REF"
      colnames(master_df)[1]<-"total_marker"
      master_df$celltype <- rownames(master_df)

      #6. Loop through each cluster, find their markers, bind to masterdf
      for (i in c(1:length(unique(ann@ann1$query$cluster)))) {
         x=master_df[master_df$cluster=="REF",]
         x$cluster = unique(ann@ann1$query$cluster)[i]
         x$total_marker=SAHA_lookup_cluster(unique(ann@ann1$query$cluster)[i],ann)
         x$celltype = rownames(x)
         master_df=rbind(master_df,x)
      }

      #7. Find proportion
      master_df$prop="NA"
      for (j in c(1:length(unique(ann@ann1$query$cluster)))) {
         master_df[master_df$cluster==unique(ann@ann1$query$cluster)[j],"prop"]=master_df[master_df$cluster==unique(ann@ann1$query$cluster)[j],"total_marker"]/master_df[master_df$cluster=="REF","total_marker"]
      }

      #8. Find p value
      master_df$pvalue = 1
      
      j=1
      k=1
      suppressWarnings(
      for (j in c(1:length(unique(ann@ann1$query$cluster)))) {
         # Size of possible markers in a given cluster
         A = length(ann@ann1$query[ann@ann1$query$cluster == unique(ann@ann1$query$cluster)[j], "gene"])
         # Size of signature testing (number of genes in pangloa cell type)
         for (k in c(1:length(unique(master_df$celltype)))) {
            B = master_df[master_df$cluster=="REF",][k,"total_marker"]
            # Overlap
            t = master_df[master_df$cluster==unique(ann@ann1$query$cluster)[j],][k,"total_marker"]
            # Length of all possible cluster markers (not just the one testing)
            n = length(unique(ann@ann1$query$gene))
            master_df[master_df$cluster==unique(ann@ann1$query$cluster)[j],][k,"pvalue"]=sum(stats::dhyper(t:B, A, n - A, B))
         }
      })

      #9. Conditional Facet
      #10. Default everything to F, not significant
      master_df$sig = "F"
      master_df[is.na(master_df$pvalue),"pvalue"]<-1
      master_df[master_df$pvalue <= 0.05,"sig"]="T" # Label only significant groups

      # Convert the 'cluster' variable to a factor with custom levels in ascending order
      master_df$cluster <- factor(master_df$cluster, levels = rev(unique(master_df$cluster)))

      # Create dataframe that only finds minimum pvalue for each cluster
      master_df <- master_df %>%
         group_by(cluster) %>%
         mutate(top_sig = ifelse(pvalue == min(pvalue) & sig == "T", "T", "F"),
                top_sig_prop = ifelse(top_sig == "F", 0, as.numeric(prop))) %>%
         ungroup()
      master_df <- data.frame(master_df)

      invisible(list(master_df = master_df, query_data = ann@ann1$query, marker_data = ann@ann1$db ))
      ann@ann2=master_df
      return(ann)
}


Create_MarkerBased_Viz <- function (ann, meta, facet){ 
   if (inherits(meta, "data.frame")) {
      # If query is already a data frame, use it directly
      meta <- meta
   } else {
      # If query is a path to a CSV file, read it into a data frame
      meta <- read.csv(meta)
   } 
  master_df = ann@ann2 
  #master_df = ann2 #######need to change to a list where master_df is added!!!!!!!!!!!!
  ##
  master_df$celltype <- gsub("-", " ", master_df$celltype)
  temp_met=meta[meta$subclass_spa %in% unique(master_df$celltype),]
  
  ###########ALL marker names need to have all spaces and NOT - !! - then this will work...
  
  master_df$class <- sapply(master_df$celltype, function(x) {
    match_idx <- match(x, temp_met$subclass_spa)
    if (length(match_idx) > 0) temp_met$class[match_idx] else NA
  })
  
  master_df$class_color <- sapply(master_df$celltype, function(x) {
    match_idx <- match(x, temp_met$subclass_spa)
    if (length(match_idx) > 0) temp_met$class_color[match_idx] else NA
  })
  
  master_df$nt <- sapply(master_df$celltype, function(x) {
    match_idx <- match(x, temp_met$subclass_spa)
    if (length(match_idx) > 0) temp_met$neurotransmitter[match_idx] else NA
  })
  
  master_df$nt_color <- sapply(master_df$celltype, function(x) {
    match_idx <- match(x, temp_met$subclass_spa)
    if (length(match_idx) > 0) temp_met$neurotransmitter_color[match_idx] else NA
  })
  

   # Create the ggplot plot with the ordered 'cluster' variable -- ALL



  p1 <- ggplot(data = subset(master_df, cluster != "REF"),
                aes(x = celltype, y = cluster, alpha = as.numeric(-log(pvalue,10)))) +
         geom_point(aes(size = as.numeric(prop), color = sig)) +
         scale_size_continuous(limits = c(0, 1), breaks = seq(0, 1, by = 0.25)) +
         labs(title = "Every Cell Type by Cluster", x = " ", y = "Cluster") +
         scale_color_manual(values = c("black", "red")) +
         theme_bw() +
         theme(axis.text.x = element_text(angle = 90, hjust = 1),
               axis.text.y = element_text(size = 8),
               plot.title = element_text(size = 10),
               strip.text = element_text(size = 8))
   
  if (facet == TRUE) {
    p1 <- p1+facet_grid(~class, scales="free_x")
  }

   # Barplot showing total available markers and proportion covered
   p2 <- ggplot(data = subset(master_df, cluster == "REF"), aes(x = celltype, y = total_marker)) +
      geom_bar(stat = "identity", fill = "Black") +
      geom_text(aes(label = total_marker), vjust = -0.5, size = 3) +
      labs(title = "Total Amount of %s Markers in %s Database", y = "Proportion") +
      theme_bw() +
      theme(axis.text.x = element_text(angle = 90, hjust = 1),
            axis.text.y = element_text(size = 8),
            plot.title = element_text(size = 10),
            strip.text = element_text(size = 8)) +
      coord_cartesian(ylim = c(0, max(master_df$total_marker) * 1.05))

   
     
      # Create the ggplot plot with the ordered 'cluster' variable -- ONLY SIGNFICANT without facet grid
      p3 <- ggplot(data = subset(master_df, cluster != "REF"),
                   aes(x = celltype, y = cluster, alpha = as.numeric(-log(pvalue,10)))) +
         geom_point(aes(size = as.numeric(prop), color = sig)) +
         scale_size_continuous(limits = c(0, 1), breaks = seq(0, 1, by = 0.25)) +
         labs(title = "Every Cell Type by Cluster", x = " ", y = "Cluster") +
         scale_color_manual(values = c("white", "red")) +
         theme_bw() +
         theme(axis.text.x = element_text(angle = 90, hjust = 1),
               axis.text.y = element_text(size = 8),
               plot.title = element_text(size = 10),
               strip.text = element_text(size = 8))
  if (facet == TRUE) {
    p3 <- p3+facet_grid(~class, scales="free_x")
  }

      
      
      # Create the ggplot plot with the ordered 'cluster' variable -- ONLY TOP SIGNFICANT without facet grid
      p4 <- ggplot(data = subset(master_df, cluster != "REF"),
                   aes(x = celltype, y = cluster, alpha = as.numeric(-log(pvalue,10)))) +
         geom_point(aes(size = as.numeric(prop), color = top_sig)) +
         scale_size_continuous(limits = c(0, 1), breaks = seq(0, 1, by = 0.25)) +
         labs(title = "The Most Significant Cell Type by Cluster", x = " ", y = "Cluster") +
         scale_color_manual(values = c("white","red")) +
         theme_bw() +
         theme(axis.text.x = element_text(angle = 90, hjust = 1),
               axis.text.y = element_text(size = 8),
               plot.title = element_text(size = 10),
               strip.text = element_text(size = 8))
  if (facet == TRUE) {
    p4 <- p4+facet_grid(~class, scales="free_x")
  }

      
      
   ann@results$marker_based$markers_barplot=p2
   ann@results$marker_based$dotplot_all=p1
   ann@results$marker_based$dotplot_sig=p3
   ann@results$marker_based$dotplot_best=p4
   return(ann)
}

#Deeper visualization (Venn and explorable)
Investigate_Marker_Based <- function(ann, query_cluster, db_cell_type = NULL, plot = NULL) {
  
  #1. Read in your queried data as a df or csv
  query_data <- ann@ann1$query
  marker_data <- ann@ann1$db
  
  #3. Formatting data
  # Calculate the number of all unique genes
  i = query_data[query_data$cluster == query_cluster, "gene"] # Genes for the specified cluster
  
  #4. Set up Venn
  if (plot == "venn") {
    
    # Filter marker_data for cluster_markers and db_cell_markers
    cluster_markers <- unique(query_data[query_data$gene %in% i, "gene"])
    db_cell_markers <- unique(marker_data[marker_data$cluster == db_cell_type, "SYMBOL"])
    
    # Create a list of sets
    sets <- list(`Query Cluster` = cluster_markers, `DB celltype` = db_cell_markers)
    
    # Generate the Euler diagram
    euler_venn <- euler(sets)
    
    # Open a new plotting window
    plot.new()
    
    # Adjust plot aesthetics
    print(plot(euler_venn, 
               labels = c(paste("Cluster", query_cluster), paste("DB:", db_cell_type)), 
               quantities = TRUE, 
               font.main = 14, 
               font.sub = 12,
               shape = "circle", 
               fill = list(fill = c("pink", "gray"))))
  }

  #5. Set up Stacked
  if (plot == "stacked") {
    # Combine the two sets of data
    combined_data <- t(rbind(
      summary(factor(marker_data$cluster)),
      summary(factor(marker_data[marker_data$SYMBOL %in% i, "cluster"], levels = levels(factor(marker_data$cluster))))
      ))
    combined_data[,1]=combined_data[,1]-combined_data[,2]
    # Convert to data frame
    plot_data <- data.frame(
      celltype = factor(rownames(combined_data)),
      Database = as.numeric(combined_data[, 1]),
      Cluster = as.numeric(combined_data[, 2])
    )
    # Reshape the data into long format
    plot_data_long <- plot_data %>%
      tidyr::pivot_longer(cols = c(Database, Cluster), names_to = "variable", values_to = "value")
    # Plot stacked barplot
    print(ggplot(plot_data_long, aes(x = celltype, y = value, fill = fct_rev(variable))) +
            geom_bar(stat = "identity") +
            labs(title = "Stacked Barplot", y = "Count", x = "Cell Type", fill = "") +
            theme_bw() +
            theme(axis.text.x = element_text(angle = 90,hjust=1),
                  axis.text.y = element_text(size = 8),
                  plot.title = element_text(size = 10),
                  strip.text = element_text(size = 8)) +
            scale_fill_manual(values = c("Cluster" = "red", "Database" = "black"), labels = c("Database" = "Database", "Cluster" = paste0("Cluster ", query_cluster))))
  }
  
  #6. Create if statements to help guide the user
  if (is.null(plot)){
    print("You can select between two different visualization methods, 'venn' and 'stacked'")
  }
  
  if (is.null(query_cluster)) {
    print("To use this function, you need to at least select one cluster for visualization.")
  }
  
  if (is.null(db_cell_type)) {
    print(paste("You can also select a cell type found within the cluster for further analysis. Try db_cell_type = '",marker_data$cluster[1],"'."))
  }
  
  if (!is.null(db_cell_type) && db_cell_type == "all") {
    cat("Summary of cell types found in cluster ", query_cluster, ".\n", sep = "")
    cat("Pick one of the cell types to continue. \n")
    print(summary(factor(marker_data[marker_data$official.gene.symbol %in% j, "cell.type"], levels(factor(marker_data$cell.type)))))
  }
  
  if (!is.null(db_cell_type) && db_cell_type != "all") {
    query_data_names_type <- marker_data[(marker_data$cluster == db_cell_type),"SYMBOL"][marker_data[(marker_data$cluster == db_cell_type),"SYMBOL"]%in% i]
    cat("Markers for", db_cell_type, "within Cluster", query_cluster, ":", paste(sort(query_data_names_type), collapse = ", "), "\n")
    }
}





```

### Perform F2

```{r Run F2}

ann=Run_Marker_Based(ann)

ann=Create_MarkerBased_Viz(ann,meta = meta,facet = TRUE)

ann@results$marker_based$markers_barplot
ann@results$marker_based$all

Investigate_Marker_Based(ann,query_cluster = 4,plot = "stacked")

Investigate_Marker_Based(ann,query_cluster = 4,plot = "venn",db_cell_type = "295 CBN Dmbx1 Gaba")


```

## Flavor 3: Marker-free

### Functions

You can also embed plots, for example:

```{r Functions F3}
##################################
#NEED TO ADD ANN SYNTAX TO ALL####
##################################

Initialize_MarkerFree <- function(ann){
  #####CLEANING NEEDS TO BE PERFORMED PRIOR TO SAHA
  if ("X"%in%colnames(ann@query$AvgExp)) {
    rownames(ann@query$AvgExp)=ann@query$AvgExp$X
    ann@query$AvgExp = ann@query$AvgExp %>%
      select(-X)  
  }
  if (all(!duplicated(ann@db$AvgExp$SYMBOL))) {
    rownames(ann@db$AvgExp)=ann@db$AvgExp$SYMBOL
    ann@db$AvgExp = ann@db$AvgExp %>%
      select(-SYMBOL, -gene, -X)
  }else{
    ann@db$AvgExp=ann@db$AvgExp[!duplicated(ann@db$AvgExp$SYMBOL),]
    ann@db$AvgExp=ann@db$AvgExp[!is.na(ann@db$AvgExp$SYMBOL),]
    rownames(ann@db$AvgExp)=ann@db$AvgExp$SYMBOL
    ann@db$AvgExp = ann@db$AvgExp %>%
      select(-SYMBOL, -gene, -X)
  }
  return(ann)
}

#read dataframes into a list
Downsample <- function(ann){
  #3. Downsample database and query to mutually expressed genes
  query_genes=rownames(ann@query$AvgExp)
  db_ds=ann@db$AvgExp[rownames(ann@db$AvgExp)%in%query_genes,]
  query_ds=ann@query$AvgExp[rownames(ann@query$AvgExp)%in%rownames(db_ds),]
  #4. Create list of data.frames
  ann3=list("query"=query_ds, "db"=db_ds)
  #5. Check to see that all rownames of query are in rownames of db
  if (all(rownames(ann3$query)%in%rownames(ann3$db))) {
    print(paste("Downsampled query and database contain",length(rownames(ann3$query)),"genes."))
  }else{
    print("Something went wrong! It appears there are either no shared genes between query and db. Please check downsampling manually to ensure that symbols (gene names) are in the same format and that query and db share common genes for SAHA flavor 3.")
  }
  #6. Return the dataframe
  ann@ann3=ann3
  return(ann)
}

NormalizeDS <- function(ann,assay_db = "RNA",assay_query){
  #1. Pivot to a new table - query
  piv_query <- ann@ann3$query %>%
  tibble::rownames_to_column(var = "Row") %>%
  pivot_longer(cols = -Row, names_to = "cluster", values_to = "Expression")

  # average and make percentiles

  grouped_data_query <- split(piv_query, piv_query$Row)

  zscore_query <- lapply(grouped_data_query, function(gene_data) {
    gene_data$z_score <- scale(gene_data$Expression)
    return(gene_data)
  })

  avgexp_query.df <- do.call(rbind, zscore_query)
  avgexp_query.df$z_score <- as.numeric(avgexp_query.df$z_score)
  avgexp_query.df$percentile <- pnorm(avgexp_query.df$z_score)

  #2. Pivot to a new table - db
  piv_db <- ann@ann3$db %>%
  tibble::rownames_to_column(var = "Row") %>%
  pivot_longer(cols = -Row, names_to = "celltype", values_to = "Expression")

  # average and make percentiles

  grouped_data_db <- split(piv_db, piv_db$Row)

  zscore_db <- lapply(grouped_data_db, function(gene_data) {
    gene_data$z_score <- scale(gene_data$Expression)
    return(gene_data)
  })

  avgexp_db.df <- do.call(rbind, zscore_db)
  avgexp_db.df$z_score <- as.numeric(avgexp_db.df$z_score)
  avgexp_db.df$percentile <- pnorm(avgexp_db.df$z_score)
 
  #3. making comparison b/w query and ABC expression profiles for major cell types

  avgexp_db.df$celltype <- gsub(paste0("^",assay_db,"\\.g"), "", avgexp_db.df$celltype) ###########!!!!!!!!!!!need to print "Assay" into here!!
  avgexp_query.df$cluster <- gsub(paste0("^",assay_query,"\\.g"), "", avgexp_query.df$cluster) ###########!!!!!!!!!!!need to print "Assay" into here!!


  avgexp_db.df <- avgexp_db.df[c("Row", "celltype", "percentile")]
  avgexp_query.df <- avgexp_query.df[c("Row", "cluster", "percentile")]



# rearrange dataframes

  avgexp_db.df <- avgexp_db.df %>%
    pivot_longer(
      cols = starts_with("percentile"), 
      names_to = "platform", 
      values_to = "expression"
    ) %>%
    mutate(platform = "db") %>%
    unite("platform_celltype", platform, celltype, sep = ".") %>%
    pivot_wider(
      names_from = platform_celltype, 
      values_from = expression
    )


  avgexp_query.df <- avgexp_query.df %>%
    pivot_longer(
      cols = starts_with("percentile"), 
      names_to = "platform", 
      values_to = "expression"
    ) %>%
    mutate(platform = "query") %>%
    unite("platform_cluster", platform, cluster, sep = ".") %>%
    pivot_wider(
      names_from = platform_cluster, 
      values_from = expression
    )


merged.df <- merge(avgexp_db.df, avgexp_query.df, by = "Row", all.x = T, all.y = T)

merged.df <- column_to_rownames(merged.df, var = "Row")
  ann@results$marker_free$norm_merge=merged.df
  #this need to be made into a list
  return(ann)

}

CorrelateDS <- function(ann){
  # compute Pearson coefficients b/w query and ABC celltype expression profiles 
  db_columns <- colnames(ann@results$marker_free$norm_merge)[grepl("db", colnames(ann@results$marker_free$norm_merge))]
  query_columns <- colnames(ann@results$marker_free$norm_merge)[grepl("query", colnames(ann@results$marker_free$norm_merge))]
  
  correlation.df <- matrix(NA, nrow = length(query_columns), ncol = length(db_columns))
  rownames(correlation.df) <- query_columns
  colnames(correlation.df) <- db_columns

  for (i in seq_along(query_columns)) {
    for (j in seq_along(db_columns)) {
      cor_test <- cor.test(ann@results$marker_free$norm_merge[[query_columns[i]]], ann@results$marker_free$norm_merge[[db_columns[j]]], method = "pearson")
      correlation.df[i, j] <- cor_test$estimate  
    }
  }

  correlation.df <- as.data.frame(correlation.df)
  ann@results$marker_free$corr=correlation.df
  return(ann)
 }

Create_MarkerFree_Viz <- function(ann, facet, meta,ABC,chemistry){
  
  # set global heatmap options
  ht_opt(RESET = TRUE)
  ht_opt(legend_border = "black",
       heatmap_border = TRUE)


  # set colors for heatmap

  col_fun = colorRamp2(c(-1, 0, 1), c("#05409e", "white", "#e64a02"))

  ann3=ann@results$marker_free$corr
  
  # make data matrix
  rownames(ann3) <- gsub("^query\\.", "", rownames(ann3))
  colnames(ann3) <- gsub("^db\\.", "", colnames(ann3))

  mat <- data.matrix(ann3)
  if (facet=="TRUE") {
    # heatmap annotation for levels

    annotation_data <- meta[meta$subclass_per %in% colnames(mat), ]
    if (ABC == "TRUE") {
      annotation_data <- annotation_data[annotation_data$library_method %in% chemistry, ]
    }
    
    annotation_data <- na.omit(annotation_data[match(colnames(mat), annotation_data$subclass_per), ])



    # set colors for annotation based on ABC-assigned colors

    neurotransmitter_unique <- annotation_data %>% distinct(neurotransmitter, .keep_all = TRUE)
    neurotransmitter_colors <- setNames(neurotransmitter_unique$neurotransmitter_color, nm = neurotransmitter_unique$neurotransmitter)

    class_unique <- annotation_data %>% distinct(class, .keep_all = TRUE)
    class_colors <- setNames(class_unique$class_color, class_unique$class)



    # create annotation

    ha <- HeatmapAnnotation(
      Neurotransmitter = annotation_data$neurotransmitter,
      Class = annotation_data$class,
      col = list(
        Class = class_colors,
        Neurotransmitter = neurotransmitter_colors
      )
    )


    ht1 <- Heatmap(mat,
               name = "Pearson R",
               col = col_fun,
               cluster_rows = T,
               cluster_columns = T,
               row_names_side = "left",
               row_names_gp = gpar(fontsize = 11),
               column_names_side = "bottom",
               column_names_gp = gpar(fontsize = 11),
               row_title = "Xenium cluster",
               row_title_rot = 90,
               row_title_side = "left",
               row_title_gp = gpar(fontface = "bold"),
               column_title = "ABC atlas",
               column_title_rot = 0,
               column_title_side = "bottom",
               column_title_gp = gpar(fontface = "bold"),
               top_annotation = ha)
  }else{
    ht1 <- Heatmap(mat, 
               name = "Pearson correlation", 
               col = col_fun, 
               cluster_rows = T, 
               cluster_columns = T, 
               row_names_side = "left",
               row_names_gp = gpar(fontsize = 11),
               column_names_side = "bottom",
               column_names_gp = gpar(fontsize = 11),
               row_title = "query cluster",
               row_title_rot = 90,
               row_title_side = "left", 
               row_title_gp = gpar(fontface = "bold"),
               column_title = "db",
               column_title_rot = 0,
               column_title_side = "bottom",
               column_title_gp = gpar(fontface = "bold"))
  
  }
  
  
  
  ann@results$marker_free$heatmap=ht1
  return(ann)
}

Investigate_MarkerFree = function(ann,query_cluster, db_cell_type){
  # Extract gene expression data for the cluster of interest
  x_data <- ann@results$marker_free$norm_merge[,paste0("query.",query_cluster)]
 
  # Extract gene expression data for the best match cluster
  y_data <- ann@results$marker_free$norm_merge[,paste0("db.",db_cell_type)]
 
  
  # Combine the data into a data frame for plotting
  plot_data <- data.frame(
    Gene = rownames(ann@results$marker_free$norm_merge),
    Expression_in_Interest_Cluster = x_data,
    Expression_in_Best_Match_Cluster = y_data,
    Difference = abs(x_data - y_data)
  )
 
  top_10_genes <- plot_data[order(-plot_data$Expression_in_Best_Match_Cluster), ][1:10, ]
 
  top_5_outliers <- plot_data[order(-plot_data$Difference), ][1:5, ]
 
  # Create the scatter plot
  p1 = ggplot(plot_data, aes(x = Expression_in_Interest_Cluster, y = Expression_in_Best_Match_Cluster)) +
    geom_point() +
    geom_label_repel(data = top_10_genes, aes(label = Gene), max.overlaps = 20, fill = "lightblue") +
    geom_label_repel(data = top_5_outliers, aes(label = Gene), max.overlaps = 20, fill = "#f78a5c") +
    labs(
      title = paste("Gene Expression in", query_cluster, "vs", db_cell_type),
      x = paste("Expression in", query_cluster),
      y = paste("Expression in", db_cell_type)
    ) +
    theme_bw()
  print(p1)
}

#scatter("Xenium.1", rearranged_merged.df, best_match.df)



```

### Perform F3

```{r Run F3}
#NEED TO FIGURE THIS ONE OUT!!!!
#ann=Create_SAHA_object(query = demo_AE,db = ABC_CB_AE,data_type = "AvgExp")

ann=Initialize_MarkerFree(ann = ann)

ann=Downsample(ann)

ann=NormalizeDS(ann,assay_query = "RNA")

ann=CorrelateDS(ann)

ann=Create_MarkerFree_Viz(ann,facet = TRUE,meta = meta, ABC = TRUE, chemistry = "10Xv3")

ann@results$marker_free$heatmap

Investigate_MarkerFree(ann = ann,query_cluster = 4,db_cell_type = "327.Oligo.NN")


```

##Plotting Fxns
```{r}
#Need to work on making these pretty....

call_SAHA_plots <- function(ann, plot_type, data_type=NULL){
  if (is.null(data_type)) {
    paste0("SAHA detected ", ann@data_type, " information loaded. If the appropriate results do not display please ensure the pipeline has been run & results have been saved in ann@results.")
    if (ann@data_type == "Markers" & plot_type == "self-similarity") {
      ann@results$self_similarity$similiarity_heatmap_markers
    }else if (ann@data_type == "AvgExp" & plot_type == "self-similarity"){
      ann@results$self_similarity$similiarity_heatmap_avgexp
    }else if (ann@data_type == "Markers" & plot_type == "Marker-based"){
      ann@results$marker_based$all
    }else if (ann@data_type == "Markers" & plot_type == "Marker-free"){
      ann@results$marker_free$heatmap
    }else { print("Multiple data types detected, please specify data_type you would like to visualize.")}
  }else{
    paste0("You have selected to visualize ", data_type,".")
      if (data_type == "Markers" & plot_type == "self-similarity") {
      ann@results$self_similarity$similiarity_heatmap_markers
    }else if (data_type == "AvgExp" & plot_type == "self-similarity"){
      ann@results$self_similarity$similiarity_heatmap_avgexp
    }else if (data_type == "Markers" & plot_type == "Marker-based"){
      ann@results$marker_based$all
    }else if (data_type == "AvgExp" & plot_type == "Marker-free"){
      ann@results$marker_free$heatmap
    }  
  }
}

```



##Auto annotate
```{r}

AutoAnnotate = function(ann, data_type=NULL){
  if(is.null(data_type)){
    print("We gently discourage auto-annotation. If you wish to proceed please select which data_type to auto-annotate using: Markers, AvgExp, or Both")
  }else if(data_type=="Markers"){
    best_match.df <-  ann@ann2 %>%
    group_by(cluster) %>%
    filter(any(pvalue < 0.05)) %>%
    slice_min(pvalue) %>%
    ungroup() %>%
    mutate(celltype = ifelse(is.na(celltype), "UNKNOWN", celltype))%>%
    select(cluster,celltype, prop, pvalue)%>% 
    as.data.frame()
    colnames(best_match.df)[2]="best_match"
    return(best_match.df)

  }else if(data_type=="AvgExp"){
    best_match.df <- data.frame(row.names = rownames(ann@results$marker_free$corr),
                            best_match = apply(ann@results$marker_free$corr, 1, function(row) names(ann@results$marker_free$corr)[which.max(row)]),
                            correlation = apply(ann@results$marker_free$corr, 1, max))
    colnames(best_match.df)[2]="best_match"
    return(best_match.df)
  }else if(data_type=="Both"){
    best_match.Markers <-  ann@ann2 %>%
      group_by(cluster) %>%
      filter(any(pvalue < 0.05)) %>%
      slice_min(pvalue) %>%
      ungroup() %>%
      mutate(celltype = ifelse(is.na(celltype), "UNKNOWN", celltype))%>%
      select(cluster,celltype, prop, pvalue)%>% 
      as.data.frame()
    
     best_match.AvgExp <- data.frame(row.names = rownames(ann@results$marker_free$corr),
                            best_match = apply(ann@results$marker_free$corr, 1, function(row) names(ann@results$marker_free$corr)[which.max(row)]),
                            correlation = apply(ann@results$marker_free$corr, 1, max))
     best_match.AvgExp$cluster<- gsub(paste0("^query\\."), "", rownames(best_match.AvgExp))
     best_matches=full_join(best_match.AvgExp,y = best_match.Markers)
     best_matches <- best_matches %>%
      #select(best_match) %>%
      mutate(best_match_avg = str_replace(best_match, "^db\\.", "")) %>%
      mutate(best_match_avg = str_replace_all(best_match_avg, "\\.", " "))
     
     best_matches <- best_matches %>%
  mutate(consensus = if_else(str_remove_all(celltype, "\\s+") == str_remove_all(best_match_avg, "\\s+"), "MATCH", "DISAGREEMENT"))
     best_matches <- best_matches %>%
        mutate(final_output = if_else(consensus == "MATCH", celltype, "INCONCLUSIVE"))
     best_matches[is.na(best_matches)]<-"INCONCLUSIVE"
     best_matches <- best_matches %>%
       select(cluster, celltype,best_match_avg,consensus,final_output)
     colnames(best_matches)=c("cluster","marker_based","marker_free","consensus","best_match")
     return(best_matches)
  }
}


#### liams best match

    
SemiAutoAnnotate = function(ann,data_type=NULL){
  #prompt through each one
   if(is.null(data_type)){
    print("Thank you for choosing the semi-automated approach. If you wish to proceed please select which data_type to auto-annotate using: Markers, AvgExp, or Both")
  }else if(data_type=="Markers"){
   
   temp=ann@results$marker_based$all
   hand_names=data.frame(unique(temp$data$cluster))
   colnames(hand_names)[1]="old_names"
   hand_names$new_names=""
   for (i in hand_names$old_names) {
     temp2=temp
     temp2$data=temp$data[temp$data$cluster==i,]
     print(temp2+theme(legend.position = "none"))
     x=readline(paste0("What would you like to name cluster ",i,": "))
     hand_names[hand_names$old_names==i,"new_names"]=x
   }
   return(hand_names)
   
   
  }else if(data_type=="AvgExp"){
   ann3=ann@results$marker_free$corr
   rownames(ann3) <- gsub("^query\\.", "", rownames(ann3))
   colnames(ann3) <- gsub("^db\\.", "", colnames(ann3))
   hand_names=data.frame(rownames(ann3))
   colnames(hand_names)[1]="old_names"
   hand_names$new_names=""
   for (i in hand_names$old_names) {
     temp = ann3[i,]
     mat <- data.matrix(temp)
      print(Heatmap(mat, 
               name = "Pearson correlation",
               cluster_columns = F, 
               row_names_side = "left",
               row_names_gp = gpar(fontsize = 11),
               column_names_side = "bottom",
               column_names_gp = gpar(fontsize = 11),
               row_title = "query cluster",
               row_title_rot = 90,
               row_title_side = "left", 
               row_title_gp = gpar(fontface = "bold"),
               column_title = "db",
               column_title_rot = 0,
               column_title_side = "bottom",
               column_title_gp = gpar(fontface = "bold")))
     x=readline(paste0("What would you like to name cluster ",i,": "))
     hand_names[hand_names$old_names==i,"new_names"]=x
   }
   return(hand_names)
   
   
  
  }else if(data_type=="Both"){
   ann2=ann@results$marker_based$all
   hand_names1=data.frame(unique(ann2$data$cluster))
   colnames(hand_names1)[1]="old_names"
   ann3=ann@results$marker_free$corr
   rownames(ann3) <- gsub("^query\\.", "", rownames(ann3))
   colnames(ann3) <- gsub("^db\\.", "", colnames(ann3))
   hand_names2=data.frame(rownames(ann3))
   colnames(hand_names2)[1]="old_names"
   hand_names=merge(hand_names1,hand_names2)
   hand_names <- hand_names %>% arrange(desc(old_names))
   hand_names$new_names=""
   for (i in hand_names$old_names[1:2]) {
     temp2=ann2
     temp2$data=ann2$data[ann2$data$cluster==i,]
     p1=temp2+theme(legend.position = "none")
     temp = ann3[i,]
     mat <- data.matrix(temp)
     p2=Heatmap(mat, 
               name = "Pearson correlation",
               cluster_columns = F, 
               row_names_side = "left",
               row_names_gp = gpar(fontsize = 11),
               column_names_side = "bottom",
               column_names_gp = gpar(fontsize = 11),
               row_title = "query cluster",
               row_title_rot = 90,
               row_title_side = "left", 
               row_title_gp = gpar(fontface = "bold"),
               column_title = "db",
               column_title_rot = 0,
               column_title_side = "bottom",
               column_title_gp = gpar(fontface = "bold"))
     p2_grob <- grid.grabExpr(draw(p2))
     print(ggarrange(p1,p2_grob,nrow = 2))
     x=readline(paste0("What would you like to name cluster ",i,": "))
     hand_names[hand_names$old_names==i,"new_names"]=x
   }
   return(hand_names)
   
  }
  
}



    
```

```{r}
#Quickstart

SAHA <- function(query,db,meta,data_type){
  ann=Create_SAHA_object(query = query,db = db,data_type = data_type)
  if (data_type=="Markers") {
    ann=Initialize_Markers(ann)
    ann=Tune_Markers(ann = ann,method = "absolute",method_value = 100,method_var = "avg_log2FC",set = "db")
    ann=Tune_Markers(ann = ann,method = "relative",method_value = 0.75,method_var = "avg_log2FC",set = "query")
    ann=Run_Marker_Based(ann)
    ann=Create_MarkerBased_Viz(ann,meta = meta,facet = TRUE)
    return(call_SAHA_plots(ann, plot_type = "Marker-based",data_type = "Markers"))
  }else if (data_type=="AvgExp") {
    ann=Initialize_MarkerFree(ann = ann)
    ann=Downsample(ann)
    ann=NormalizeDS(ann,assay_query = "RNA")
    ann=CorrelateDS(ann)
    ann=Create_MarkerFree_Viz(ann,facet = TRUE,meta = meta, ABC = TRUE, chemistry = "10Xv3")
    return(call_SAHA_plots(ann, plot_type = "Marker-free",data_type = "AvgExp"))
  }else{
    print("Something went wrong. Please read the documentation or consider running the full SAHA pipeline.")
  }
}


```


